module Parser where

import Utils
import Data.Either

data Instruction = CONCAT Int
                 | DEL
                 | LOOP
                 | NOP
                 | SWAP Int
                 | ADD String String String
                 | DIV String String String
                 | MOD String String String
                 | MOVE String String String
                 | MUL String String String
                 | POW String String String
                 | SUB String String String
                 deriving (Eq)

instance Show Instruction where
    show (CONCAT a) = "CONCAT "++show a
    show (LOOP) = "LOOP"
    show (NOP) = "NOP"
    show (SWAP a) = "SWAP "++show a
    show (ADD d s1 s2) = "ADD "++d++", "++s1++", "++s2
    show (DIV d s1 s2) = "DIV "++d++", "++s1++", "++s2
    show (MOD d s1 s2) = "MOD"++d++", "++s1++", "++s2
    show (MOVE d s1 s2) = "MOVE"++d++", "++s1++", "++s2
    show (MUL d s1 s2) = "MUL"++d++", "++s1++", "++s2
    show (POW d s1 s2) = "POW"++d++", "++s1++", "++s2
    show (SUB d s1 s2) = "SUB"++d++", "++s1++", "++s2

data Pragma = Sym_table_size Int
            | Requires String
            deriving (Eq)

instance Show Pragma where
    show (Sym_table_size a) = "@pragma sym_table_size "++show a
    show (Requires a) = "@pragma requires "++a

data Type = TEXT
          | NUMBER
          | FLOAT
          | DELIMITER
          | SYMBOL
          | EMPTY
          | DERIVED
          deriving Show

data PassType = WordsPass
              | WordsPassCont
              | LinesPass
              | ExpressionPass Type
              | MatchPass String
              
instance Show PassType where
    show (WordsPass) = "Pass Words"
    show (WordsPassCont) = "WordsPassCont"
    show (LinesPass) = "Pass Lines"
    show (ExpressionPass t) = "Pass " ++ show t ++ " Expression"
    show (MatchPass s) = "Pass \"" ++ s ++ "\" Expression"

type Pass = (PassType, [Instruction])

type Ebel = [Pass]

type EbelProgram = ([Pragma], Ebel)

data Expr = Var
          | IVal Int
          | FVal Float
          | EADD Expr Expr
          | EDIV Expr Expr
          | EMOD Expr Expr
          | EMUL Expr Expr
          | EPOW Expr Expr
          | ESUB Expr Expr
          deriving (Show)

genVar :: Int -> String
genVar v = "$"++(show v)

expr2Ebel :: Int -> Expr -> Either String (Int, [Instruction])
    -- ADD
expr2Ebel v (EADD Var Var) = Right (v, [ADD (genVar v) "$" "$"])
expr2Ebel v (EADD Var (IVal a)) = Right (v, [ADD (genVar v) "$" (show a)])
expr2Ebel v (EADD (IVal a) Var) = Right (v, [ADD (genVar v) (show a) "$"])
expr2Ebel v (EADD (IVal a) (IVal b)) = Right (v, [ADD (genVar v) (show a) (show b)])
    -- Var
expr2Ebel v Var = Right (v, [MOVE "$" "$" "$"])
    -- Nested
expr2Ebel v (EADD a b) = Right (v, (snd ar)++(snd br)++[ADD (genVar v) (genVar (fst ar)) (genVar (fst br))])
    where
        a1 = expr2Ebel (v+1) a
        b1 = expr2Ebel (v+2) b
        ar = fromRight (-1, []) (a1)
        br = fromRight (-1, []) (b1)

str2Expr :: String -> Either String Expr
str2Expr [] = Left "Empty expression"
 
instr2StrT :: Int -> [Instruction] -> String
instr2StrT _ [] = ""
instr2StrT tab (i:is) = (replicate tab ' ') ++ show i ++ "\n" ++ instr2StrT tab is

pass2StrT :: Int -> Pass -> String
pass2StrT tab (ExpressionPass t, i) = (replicate (tab+2) ' ') ++ show (ExpressionPass t) ++ "\n" ++ instr2StrT (tab+4) (init i) ++ (replicate (tab+4) ' ') ++ "RETURN " ++ show (last i) ++ "\n"
pass2StrT tab (MatchPass s, i) = (replicate (tab+2) ' ') ++ show (MatchPass s) ++ "\n" ++ instr2StrT (tab+4) (init i) ++ (replicate (tab+4) ' ') ++ "RETURN " ++ show (last i) ++ "\n"
pass2StrT tab (WordsPassCont, i) = (replicate tab ' ') ++ instr2StrT (tab+2) i
pass2StrT tab (p, i) = (replicate tab ' ') ++ show p ++ "\n" ++ instr2StrT (tab+2) i

pragmas2Str :: [Pragma] -> String
pragmas2Str [] = ""
pragmas2Str (p:ps) = show p ++ "\n" ++ pragmas2Str ps

pass2Str :: [Pass] -> String
pass2Str [] = ""
pass2Str (p:ps) = pass2StrT 0 p ++ pass2Str ps

ebel2Str :: EbelProgram -> String 
ebel2Str (pr, ps) = "# Generated by " ++ bee_hs_name ++ "\n" ++ pragmas2Str pr ++ pass2Str ps

exampleEbel = ([Requires "0.3.1"], [(WordsPass, [])]++[(MatchPass "42", (snd $ fromRight (-1, []) (expr2Ebel 0 (EADD (EADD (IVal 42) Var) (EADD (EADD (IVal 8) (IVal 8)) (EADD (IVal 10) (Var))))))++[NOP])]++[(WordsPassCont, [LOOP])])
